[TOC]

### 排序

#### 分类

- 内部排序：排序期间元素全部存放在内存中的排序；
- 外部排序：排序期间内存无法全部同时存放在内存中，必须在排序的过程中根据要求不断的在内外存之间移动的排序；
- 插入排序、交换排序、选择排序、归并排序、基数排序；
- 内部排序的性能取决于算法的时间复杂度和空间复杂度；

#### 插入排序

##### 直接插入排序

```c
void InsertSort(ElemType A[],int n){
    int i,j;
    for(i = 2;i <= n;i++)				//依次将A[2]~A[n]插入前面已排序序列
        if(A[i]>A[i-1]){				//若A[i]的关键字小于其前驱，将A[i]插入到有序表
            A[0] = A[i];				//复制为哨兵，A[0]不存放元素
            for(j = i-1;A[0] < A[j];--j)  //从后往前查找待插入位置
                A[j+1] = A[j];			 //向后挪位
            A[j+1] = A[0];				 //复制到插入位置
        }
}
```

- 空间效率：仅用了单个辅助单元，因而空间复杂度为$$O(1)$$；
- 时间效率：平均情况下，总的比较次数和总的移动次数均为$$n^2/4$$，时间复杂度为$$O(n^2)$$；
- 稳定性：由于每次插入元素总是从后往前先比较再移动，所以不会出现相同元素对应位置发生改变的情况；
- 适用性：顺序存储和链式存储的线性表；链式存储时可以从前往后查找指定元素的位置；

##### 折半插入排序

```c
void BInsertSort(Elemtype A[],int n){
    int i,j,low,high,mid;
    for(i = 2; i <= n; i++){				 //依次将A[2]~A[n]插入前面已排列好的序列
        A[0] = A[i];						//将A[i]暂存到A[0]
        low = 1;high = i-1;					 //设置折半查找范围
        while(low<=high){					 //折半查找（递增有序）
            mid = (low+high)/2;				  //去中间点
            if(A[mid] > A[0]) high = mid-1;	   //查找左半子表
            else			 low = mid+1;	  //查找右半子表
        }
        for(j = i-1; j >= n;--j)
            	A[j+1] = A[j];				  //同一后移元素
        A[high+1] = A[0];					  //插入
    }
}
```

- 比较元素的次数约为$$O(nlog_2n)$$，比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；元素的移动次数并未改变，它依赖于待排序表的初始状态；
- 时间复杂度：$$O(n^2)$$；
- 稳定性：一种稳定的排序算法；
- 适用性：数据量不是很大的排序表；

##### 希尔排序

```c
void ShellSort(ElemType A[],int n){
    //A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
    int dk,i,j;
    for(dk = n/2; dk >= 1; dk=dk/2)							//步长变化
        for(i = dk+1; i <= n; ++i）
            if(A[i] < A[i-dk]){								//需将A[i]插入有序增量子表
            	A[0] = A[i];							    //暂存在A[0]
            	for(j = i-dk; j > 0 && A[0] < A[j]; j-=dk)
                	A[j+dk] = A[j];							 //记录后移
            	A[j+dk] = A[0];								 //插入
        }
}
```

- 空间效率：仅用了常数个辅助单元，空间复杂度为$$O(1)$$；
- 时间效率：依赖于增量序列的函数，当n在某个特定的范围时时间复杂度约为$$O(n^{1.3})$$；在最坏的情况下为$$O(n^2)$$；
- 稳定性：当相同的关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序；
- 适用性：仅适用于线性表为顺序存储的情况；

#### 交换排序

##### 冒泡排序

```c
void BubbleSort(ElemType A[],int n){
    int i,j;
    bool flag;							//表示本趟冒泡排序是否发生交换的标志
    for(i = 0; i < n; i++){				 
        flag = false;
        for(j = n-1; j > i; j--)		 //一趟冒泡过程
            if(A[j-1] > A[j]){			 //若为逆序
                swap(A[j-1],A[j]);		 //交换
                flag = true;
            }
        if(flag == false)
            return;						 //本趟遍历没有发生交换，说明表已经有序
    }
}
```

- 空间效率：仅使用了常数个辅助单元，因而空间复杂度为$$O(1)$$；
- 时间效率：最好情况下时间复杂度为$$O(n)$$，最坏情况下时间复杂度$$O(n^2)$$，平均时间复杂度为$$O(n^2)$$；
- 稳定性：由于$$i>j$$且$$A[i]=A[j]$$时不会发生交换；
- 冒泡排序中所产生的有序子列一定是全局有序的，有序子列中的所有元素的关键字一定大于或小于无序子序列的关键字，这样每趟排序都会将一个元素放到其最终的位置上；

##### 快速排序

- 基于分治法

```c
void QuickSort(ElemType A[],int low,int high){
    if(low < high){								 //递归结束条件
        //Partition()划分操作，将A[low...high]划分为满足上述条件的子表
        int pivotpos = Partition(A,low,high);	    //划分,一次快速排序
        QuickSort(A,low,pivotpos-1);			   //依次对两个子表进行递归排序
        QuickSort(A,pivotpos+1,high);
    }
}
int Partition(ElemType A[],int low,int high){
    ElemType pivot = A[low];					   //将表中第一个元素设置为数轴，对表进行划分
    while(low < high){							   //循环跳出条件
        while(low < high && A[high] >= pivot) --high;
        A[low] = A[high];						    //将比枢轴小的元素移动到左端
        while(;ow < high && A[low] <= pivot) ++low;
        A[high] = A[low];							//将比枢轴大的元素移动到右端
    }
    A[low] = pivot;									//枢轴元素存放到最终位置
    return low;										//返回存放枢轴的位置
}
```

- 空间效率：快速排序时递归的，需要借助一个递归工作栈来保存每层递归的必要信息。其容量与递归调用的最大深度一致；最好情况下为$$O(log_2n)$$，最坏情况下要进行n-1次递归调用，所以栈的深度为$$O(n)$$，平均情况下，栈的深度为$$O(log_2n)$$；
- 时间效率：快速排序运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大限度不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，时间复杂度为$$O(n^2)$$；在最理想的情况下，快速排序的运行速度大大提升，时间复杂度为$$O(nlog_2n)$$；平均情况下运行时间与最佳情况下的运行时间很接近；快速排序是所有内部排序算法中平均性能最优的排序算法；
- 稳定性：不稳定；
- 在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴元素放到其最终的位置上；

#### 选择排序

##### 简单选择排序

```c
void SelectSort(ElemType A[],int n){
    int i,j,min;
    for(i = 0; i < n-1; i++){						//一共进行n-1趟
        min = i;								   //记录最小元素的位置
        for(j = i+1; j < n; j++)					//在A[i...n-1]中选择最小的元素
            if(A[j] < A[min])
                min = j;							//更新最小元素
        	if(min != i)
                swap(A[i],A[min]);					 //封装的swap函数共移动元素三次
    }
}
```

- 第$$i$$趟在后面$$n-i+1$$个待排元素中选取关键字最小的元素，作为有序子序列的第$$i$$个元素，直到第n+1趟做完；
- 空间效率：仅用单个常数辅助单元，空间复杂度$$O(1)$$；
- 时间效率：元素移动不会超过$$3(n-1)$$次，但比较次数始终为$n(n-1)/2$，时间复杂度始终为$$O(n^2)$$；
- 稳定性：不稳定；$L=\{2,2,1\}$； 

##### 堆排序

- 最后一个结点为$[n/2]$个结点的孩子；

```c
void BuildMaxHeap(ElemType A[],int len){
    for(int i = len/2; i > 0; i--)						//从i = [n/2] ~ 1反复调整堆
        HeadAdjust(A,i,len);
}
void HeadAdjust(ElemType A[],int k,int len){
    //将元素k为根的子树进行调整
    A[0] = A[k];										//将A[0]暂存子树的根结点
    for(int i = 2*k; i <= len; i*=2){					  //沿key较大的子结点向下筛选
        if(i < len && A[i] < A[i+1])
            i++;										//取key值较大的子结点的下标
        if(A[0] >= A[i])	break;						  //筛选结束
        else{
            A[k] = A[i];								  //将A[i]调整到双亲结点上
            k = i;										  //修改key值，以便继续向下筛选
        }
    }
    A[k] = A[0];										   //被筛选的结点放入最终位置
}
void HeapSort(ElemType A[],int len){
    BuildMaxHeap(A,len);									//初始建堆
    for(int i = len; i > 1; i--){							 //n-1趟的交换和建堆过程
        Swap(A[i],A[1]);									//输出堆顶元素（和堆底元素交换）
        HeadAdjust(A,1,i-1);								 //调整，把剩余的i-1个元素整理成堆
    }
}
```

- 调整的时间与高度有关，为$$O(h)$$，在建n个元素的堆时，关键字的比较总次数不超过4n，时间复杂度为$$O(n)$$，这说明可以在线性时间内将一个无序数组建成一个堆；
- 插入：插入时将新结点放在堆的末端，再进行调整；
- 空间效率：空间复杂度$$O(1)$$；
- 时间效率：建堆时间为$$O(n)$$，之后有n-1次调整操作，每次调整的时间复杂度为$O(h)$，故在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$；
- 稳定性：不稳定；

#### 2路归并排序

- 基于分治法

```c
ElemType *B = (ElemType *)malloc((n+1)*sizeof(ElemType));		//辅助数组B
void Merge(ElemType A[],int low,int mid,int high){
    //表A的两端A[low...mid]和A[mid+1...high]各自有序，将它们合并成一个有序表
    int k,i,j;
    for( k = low; k <= high; k++)
        B[k] = A[k];										//将A中所有的元素复制到B中
    for( i = low, j = mid+1, k = i; i <= mid && j <= high; k++){
        if(B[i] <= B[j])									 //比较B的左右两段中的元素
            A[k] = B[i++];									 //将较小的复制到A中
        else
            A[k] = B[j++];
    }
    while(i <= mid)		A[k++] = B[i++];					  //若第一个表未检测完，复制
    while(j <= high)	A[k++] = B[j++];					  //若第二个表未检测完，复制
}
void MergeSort(ElemType A[],int low,int high){
    if(low = high){
        int mid = (low+high)/2;								  //从中间划分为两个子序列
        MergeSort(A,low,mid);								  //对左侧子序列进行递归排序
        MergeSort(A,mid+1,high);							  //对右侧子序列进行递归排序
        Merge(A,low,mid,high);								  //归并
    }
}
```

- 一趟归并操作是，调用[n/2h]次算法merge( )，将L[1,...,n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行$$[log_2n]$$趟；$k路-----[log_kn]$；
- 空间效率：Merge( )操作中，辅助空间刚好为n个单元，所以算法的空间复杂度为$O(n)$；
- 时间效率：每趟归并的时间复杂度为$O(n)$，共需进行$[log_2n]$趟归并，所以算法的时间复杂度为$O(nlog_2n)$；
- 稳定性：Merge( )操作不会改变相同关键字的相对次序，稳定；

#### 基数排序

- 空间效率：一趟排序需要的辅助存储空间为r(r个队列：r个队头指针和r个队尾指针)但会重复使用这些队列，所以空间复杂度为$O(r)$；
- 时间效率：基数排序需要进行d趟分配和收集，一趟分配需要$O(n)$，一趟收集需要$O(r)$，所以时间复杂度为$O(d(n+r))$，它与序列的初始状态无关；
- 稳定性：按位排序时必须是稳定的；

#### 内部排序算法的比较

|   算法种类   |    时间复杂度Best    |   Average    |    Worst     | 空间复杂度  | 是否稳定 |
| :----------: | :------------------: | :----------: | :----------: | :---------: | :------: |
| 直接插入排序 |        $O(n)$        |   $O(n^2)$   |   $O(n^2)$   |   $O(1)$    |    是    |
|   冒泡排序   |        $O(n)$        |   $O(n^2)$   |   $O(n^2)$   |   $O(1)$    |    是    |
| 简单选择排序 |       $O(n^2)$       |   $O(n^2)$   |   $O(n^2)$   |   $O(1)$    |    否    |
|   希尔排序   | $\approx O(n^{1.3})$ |              |   $O(n^2)$   |   $O(1)$    |    否    |
|   快速排序   |     $O(nlog_2n)$     | $O(nlog_2n)$ |   $O(n^2)$   | $O(log_2n)$ |    否    |
|    堆排序    |     $O(nlog_2n)$     | $O(nlog_2n)$ | $O(nlog_2n)$ |   $O(1)$    |    否    |
| 2路归并排序  |     $O(nlog_2n)$     | $O(nlog_2n)$ | $O(nlog_2n)$ |   $O(n)$    |    是    |
|   基数排序   |     $O(d(n+r))$      | $O(d(n+r))$  | $O(d(n+r))$  |   $O(r)$    |    是    |

- 选取排序算法需要考虑的因素：
  1. 待排序的元素数目n；
  2. 元素本身信息量的大小；
  3. 关键字的结构及分布情况；
  4. 稳定性要求；
  5. 语言工具的条件，存储结构及辅助空间的大小等；

- 若n较小，可采用直接插入排序或简单选择排序，由于直接插入排序所需的记录移动次数较简单选择排序的多，因而记录本身信息量较大时，用简单选择排序；
- 若初始状态基本有序，则选择直接插入法或冒泡排序为宜；
- 若n很大，记录的关键字位数较少且可以分解时，采用基数排序比较好；
- 当记录本身信息量较大时，为避免耗费大量时间移动记录，可以用链表作为存储结构；
- 当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要$O(nlog_2n)$的时间；
- 若n较大，则应采用时间复杂度为$O(nlog_2n)$的排序算法：快速排序、堆排序、归并排序；基于比较的内部算法最好的算法：快速排序，当待排序的关键字随机分布时，快速排序的平均时间最短；

#### 外部排序（二轮复习详记

- 在排序的过程中，需要多次进行内存和外存之间的交换；
- 外部排序的时间代价主要考虑访问磁盘的次数，即$I/O$次数；

##### 归并排序

- 包括两个独立的阶段：①根据内存缓冲区的大小，将外存上的文件分成若干长度一定的子文件，依次读入内存并利用内部排序方法对他们进行排序，并将排序后得到的有序子文件重新写会外存，称这些有序子文件为归并段或顺串；②对这些归并段进行逐趟归并，并使归并段逐渐由小到大，直到得到整个有序文件为止；

##### 多路平衡归并与败者树

##### 置换--选择排序

##### 最佳归并树